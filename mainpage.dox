/**
\mainpage
\image html http://www.shadowrobot.com/images/logo-shadowDB.png

\htmlinclude manifest.html

\section introduction Introduction
This is a generic ROS interface used to access and experiment with Shadow Robot's
hardware. It can be used either for accessing the real hardware or use a virtual hand to test your algorithm / utilities.
It also contains an interface to Shadow Robot's muscle arm.


\section howto How to use this interface
If you didn't pull the branch in the stacks (.path/to/ros/stacks), don't forget to add the path to the shadow_robot stack to your \p ROS_PACKAGE_PATH for the relevant packages to be found by ROS. To do this, edit your .bashrc:
after the line "source /path/to/ros/setup.sh", add :
\verbatim
export ROS_PACKAGE_PATH=${ROS_PACKAGE_PATH}:/path/to/shadow_robot
\endverbatim

\subsection virtualhand Virtual Hand
To run the virtual Dextrous Hand, just compile the code: 
\verbatim rosmake --rosdep-install sr_hand\endverbatim
Then start the ROS interface, if you want to have a motor hand:
\verbatim roslaunch sr_hand srh_motor.launch \endverbatim 
Otherwise, if it's a muscle hand:
\verbatim roslaunch sr_hand srh_muscle.launch \endverbatim 

\subsection realhand Real Hand
If you have a real Shadow Dextrous Hand, you need to uncomment the relevent region in the CMakelist.txt
\code
include_directories(/usr/realtime/include/)
LINK_LIBRARIES(pthread)
add_library(robot STATIC IMPORTED) 
set_property(TARGET robot PROPERTY IMPORTED_LOCATION /usr/lib/robot.a)
rosbuild_add_executable(shadowhand_real src/hand/shadowhand.cpp src/hand/real_shadowhand.cpp src/sr_publisher.cpp 
src/sr_subscriber.cpp src/hand/real_shadowhand_node.cpp src/sr_diagnosticer.cpp)
rosbuild_link_boost(shadowhand_real thread)
target_link_libraries(shadowhand_real robot)
\endcode

Then compile the code: 
\verbatim rosmake --rosdep-install sr_hand\endverbatim

You then need to modify slightly the srh_motor.launch file (or srh_muscle.launch), on line 5 replace virtual by real:
\code
<node pkg="sr_hand" name="shadowhand" type="shadowhand_real" >
\endcode

Then start the ROS interface:
\verbatim roslaunch sr_hand [srh_motor.launch/srh_muscle.launch] \endverbatim 


\subsection genericusehand Generic use - Hand
Once you run either a virtual or real hand, you can use the different tools provided by ROS / Shadow without changing
anything on either types of hand.

If you want to view the hand in \b rviz, just run 
\verbatim roslaunch sr_hand [rviz_muscle.launch/rviz_motor.launch]\endverbatim  
You then need to add one \p robot_model to visualize the current positions of the hand. To do this, click on Add at the 
bottom left of rviz, then select \b Robot \b Model. You can also visualize the targets of the hand by using a second 
\p robot_model in \b rviz. Don't forget to specify the correct topics:
\li To display the hand position: set \b Robot \b Description to \b hand_description and \b TF \b Prefix to \b /srh/position (on the
left hand side, in the parameters of your robot_model).
\li To display the hand targets: set \b Robot \b Description to \b hand_description and \b TF \b Prefix to \b /srh/target.



You should see the model displayed in rviz:
\image html http://img685.imageshack.us/img685/729/rosinterface.png

If you need to monitor the diagnostics published by the hand, you can use the following command: 
\verbatim rosrun robot_monitor robot_monitor\endverbatim .


\subsection genericusearm Generic use - Arm
To start the arm with the hand attached, run:
\verbatim roslaunch sr_hand [sr_arm_motor.launch/sr_arm_muscle.launch] \endverbatim

You can then visualize it in rviz:
\verbatim roslaunch sr_hand [rviz_motor.launch/rviz_muscle.launch] \endverbatim

You then need to add one \p robot_model to view the current positions of the arm. You can also visualize 
the targets of the arm by using a second \p robot_model in \b rviz. Don't forget to specify the correct topics:
\li To display the arm position: set \b Robot \b Description to \b arm_description and \b TF \b Prefix to \b /sr_arm/position (on the
left hand side, in the parameters of your robot_model).
\li To display the arm targets: set Robot \b Description to \b arm_description and \b TF \b Prefix to \b /sr_arm/target.

\section rosdetails Details on how all this is organized
\image html http://img143.imageshack.us/img143/8771/rosinterface.jpg

To visualize the current organization of the ros nodes, once you've started the shadowhand node by running one of the above commands,
you can run the command
\verbatim
rxplot
\endverbatim

As you can see on this diagram generated by rxplot, the shadowhand publishes to two different joint_states topics: 
one for the targets, one for the position. The joint_states topic is a topic where the current angle, velocity and
effort of each joint is published. Those joint_states topics are then transformed to position information 
by two different robot_state_publisher, using the file shadowhand.xml which contains the model of Shadow Dextrous
Hand. The robot_state_publisher then publishes on the tf topic. This tf topic can then be visualized in rviz. 
The shadowhand node publishes to the diagnostics topic which is then aggregated by a diagnostic_aggregator node. 

Additional data is also published on the /srh/shadowhand_data topic. If you want to look what's published on a topic,
you can either look at a simple example (shadowhand_subscriber.py), or simply use the command: 
\verbatim
rostopic echo /srh/shadowhand_data
\endverbatim

To send commands to the shadowhand, you can send messages to the following topics.
\li /srh/sendupdate to send new targets to the hand
\li /srh/contrlr to set the controler parameters
\li /srh/config to set the palm config

To send information to a topic, you can either use a c++ code or a python code. Please refer to the example: 
shadowhand_publisher.py.


For more information regarding those topics, please use the command \p rostopic \p info

\section srcontrolgui Control Graphical Interface
 sr_control_gui is a graphical application which integrates most of the tools needed by the end-user to control Shadow Robot's Hardware. 

\subsection howtousegui How to use the GUI.
To start the GUI, run:
\verbatim
rosrun sr_control_gui sr_control_gui
\endverbatim

The GUI is organized in tabs : 
\li    \b Hand \b control provides sliders to control the hand joint by joint, displaying actual positions and current targets set by the sliders. It also provides a grasp manager which allows to go from one saved grasp to another smoothly, moving all the fingers at the same time. It is also possible to come back to the former grasp. Finally, grasps can be saved into the grasps.xml file, using the saver. Beware, only the selected joints (ticked in the joint chooser) will be writen to the file.
\li    \b Visualisation provides various services to launch external useful programs, such as ROS utils. The main part, which is not implemented yet, will allow to choose which information should be displayed in Rviz.
\li    \b Player is used to choose a file containing a list of grasps to replay step by step. Two options are available : playing them by clicking on play for each grasps, or playing the whole file with a given time between each grasp. This is design to be used with the record button on the menu. The field must be filled with a filename to save the grasps.
\li  \b  Accessories provides services to control some spare parts of the hand, such as the Shadow Arm, which can be controled like the hand, the Cyberglove (including a calibration service) or the Cybergrasp (not implemented yet). It is also possible to change the topics read by the program in order to change the hand controled.

\section gazebo Simulation Using Gazebo 
The ROS interface comes with a model which can be used in gazebo. Gazebo is encapsulated in ROS. To compile the ROS version of gazebo, run:
\verbatim
rosmake --rosdep-install gazebo_worlds
\endverbatim

\subsection gazebolaunch Launching Gazebo and spawning your model
You then can start any model that you want using the different launchers in \b launch/gazebo.
For instance, if you want to spawn the motor hand in gazebo:
\verbatim
roslaunch sr_hand gazebo_hand_motor.launch
\endverbatim
\image html http://img839.imageshack.us/img839/1015/handgazebo1.jpg

\subsection robotmove Making your robot move
When Gazebo is running with the robot model, you can use motion commands to make the robot move.
Assuming you have the hand running (see picture above), you can move FFJ3 (the first finger proximal joint) by running:
\verbatim
rostopic pub /ffproximal_controller/command std_msgs/Float64 0.6
\endverbatim
In this example, ffproximal_controller can be any other hand controller, and 0.6 is the position of the joint, 0 being the lower limit and 1 the higher limit of the allowed motion angle.
Back in Gazebo, the finger should be like this:
\image html http://img20.imageshack.us/img20/3895/handgazebo2.jpg

\subsection pidmodify Modifying the PID values
The models that are spawned in Gazebo are moveable thanks to PID controllers, which values are easy to modify, in order to set the behaviour of the robot as you wish.
If you want to modify the hand PID values, just modify the \b model/hand_urdf/hand_controller.yaml file.
If you want to modify the arm PID values, modify the \b model/arm_urdf/arm_controller.yaml file
In those files each controller looks like:
\code
wrist_controller:
  type: robot_mechanism_controllers/JointPositionController
  joint: WRJ2
  pid:
    p: 0.0
    i: 0.0
    d: 0.0
    i_clamp: 1
\endcode
Modifying the P, I and D values will affect the speed and accuracy of your robot motions.
When those values are set, just save the file and run your launch file again to apply the modifications.


For more information on how to use gazebo in ROS, you should probably have a look at: http://www.ros.org/wiki/simulator_gazebo/Tutorials/Gazebo_ROS_API

\section codemodif Modifying the Models
The URDF Models used for the visualization (with Rviz) and the simulation (with Gazebo) are available in model/arm_urdf and model/hand_urdf.
The arm and hand models are using xacro macros, which allow different robots to be linked in Gazebo (in order to simulate the behaviour of the arm with the hand at its extremity).
If you want to modify something in the models, you have two things to do: change the informations in the right .urdf.xacro file, and then generate the .urdf file that will be used as a model.

\subsection changethexacrofile Modify the .urdf.xacro file
The architecture of the robot is as follows (each robot has a motor version and a muscle version):
\li An arm_and_hand is composed of a full_arm and a full_hand.
\li An sr_arm is composed of a single full_arm
\li A shadowhand is composed of a single full_hand
\li A full_arm is composed of a shadowarm_base, a shadowarm_trunk, a shadowarm_upperarm, a shadowarm_lowerarm and a shadowarm_handsupport
\li A full_hand is composed of a forearm, a wrist, a palm, a thumb, three fingers and a little_finger
\li A finger is composed of a knuckle, a proximal, a middle and a distal, plus a metacarpal for the little_finger.
\li A thumb is a little more complicated, with a hub and a base to add the missing motions.

All those parts are represented by "link" tags in the URDF files, and linked between them by "joint" tags.
To modify data in a part of the hand, open the right .urdf.xacro file (for example to modify the size of the last part of each finger, you want to open the model/hand_urdf/finger/distal.urdf.xacro).
Thus, the modification will be applied to all the identical parts of the hand.
Then, just save the file.

\subsection generatetheurdffile Generate the .urdf file
the .urdf.xacro model has to be turned into a classic .urdf file to be used by ROS.
To generate the good file, use the following command: (this example generates the motor version of the hand)
\verbatim
rosrun xacro xacro.py -o `rospack find sr_hand`/model/robots/shadowhand_motor.urdf `rospack find sr_hand`/model/robots/xacro/shadowhand_motor.urdf.xacro
\endverbatim
The .urdf.xacro robot model which is in the model/robots/xacro directory is turned into an urdf file in the model/robots directory
(Warning: the urdf file in the model/robots directory has to exist before running the command, because the order is to overwrite what was in the file)


\section codeapi Code API
The classes directly interacting or simulating the Dextrous hand are the following:
\li The generic parent class for the Dextrous Hands can be found at shadowhand::Shadowhand.
\li The virtual Shadow Dextrous Hand can be found here shadowhand::VirtualShadowhand.
\li To look at the real Dextrous Hand documentation refer to shadowhand::RealShadowhand.
\li The virtual Shadow Arm can be found here: shadowhand::VirtualArm.

You can find the documentation regarding the different publishers and the subscriber here: 
shadowhand_publisher::ShadowhandPublisher, shadowhand_subscriber::ShadowhandSubscriber, 
shadowhand_diagnosticer::ShadowhandDiagnosticer .

The package also contains a python library to access the ROS interface through easy to use high level
python commands. Please refer to shadowhand_ros.py. This library is used to develop the sr_control_gui interface.

\section examples Examples

There's a few examples in the examples directory in sr_hand. You can have a look at the example link_joints.cpp, or the same example written in python: link_joints.py.
To run them, just run the following commands in different terminals:
\verbatim 
roslaunch sr_hand srh_motor.launch 
roslaunch sr_hand rviz_motor.launch
rosrun sr_control_gui __init__.py 
\endverbatim

and then
\verbatim
rosrun sr_hand link_joints 
\endverbatim
or 
\verbatim
rosrun sr_hand link_joints.py
\endverbatim

If you move the joint slider for FFJ3, then MFJ3 will move as well.

\example link_joints.cpp
\example link_joints.py

*/
